// server.js

const express = require("express");
const mysql = require("mysql2/promise");
const cors = require("cors");
const dbConfig = require("./db.config.js");

const app = express();
const PORT = 3003;

// Middleware
app.use(cors());
app.use(express.json());

// Global logger for all POST requests to make debugging easier
app.use((req, res, next) => {
    if (req.method && req.method.toUpperCase() === 'POST') {
        const ts = new Date().toISOString();
        const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
        try {
            console.log(`[${ts}] POST ${req.originalUrl || req.url} from ${clientIp}`);
            console.log('   Headers:', JSON.stringify(req.headers));
        } catch (e) {
            console.log('   Headers: [unserializable]');
        }
        try {
            console.log('   Body:', JSON.stringify(req.body));
        } catch (e) {
            console.log('   Body: [unserializable]');
        }
    }
    next();
});

// --- Database Connection Pool ---
let pool;
try {
    pool = mysql.createPool(dbConfig);
    console.log("âœ… MySQL connection pool created successfully.");
} catch (error) {
    console.error("âŒ Failed to create MySQL connection pool:", error);
    process.exit(1);
}

// --- API Endpoints ---

// 1. GET: Retrieve a single asset by asset_tag
app.get("/api/assets/:assetTag", async (req, res) => {
    const { assetTag } = req.params;
    
    // LOG: Incoming request
    console.log(`\nâž¡ï¸ GET /api/assets/${assetTag}`);
    
    const query = "SELECT id, asset_tag, category, assigned_user, location_id FROM assets WHERE asset_tag = ?";
    
    // LOG: Query being executed
    console.log(`   QUERY: ${query.replace('?', `'${assetTag}'`)}`);
    
    try {
        const [rows] = await pool.execute(query, [assetTag]);
        
        if (rows.length === 0) {
            // LOG: 404 response
            console.log(`   â¬…ï¸ STATUS: 404 Not Found (Asset: ${assetTag})`);
            return res.status(404).json({ message: "Asset not found" });
        }
        
        // LOG: Success response and returned data
        console.log(`   â¬…ï¸ STATUS: 200 OK. Asset ID: ${rows[0].id}`);
        res.status(200).json(rows[0]);
    } catch (error) {
        // LOG: Error details
        console.error("   âŒ ERROR:", error.message);
        res.status(500).json({ message: "Error retrieving asset data", error: error.message });
    }
});

// 2. POST: Submit Audit Results
app.post("/api/audit/submit", async (req, res) => {
    const data = req.body || {};

    // LOG: Incoming request and payload data (enhanced for debugging)
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] POST /api/audit/submit from ${clientIp}`);
    try { console.log('   HEADERS:', JSON.stringify(req.headers)); } catch (e) { console.log('   HEADERS: [unserializable]'); }
    try { console.log('   RAW BODY:', JSON.stringify(req.body)); } catch (e) { console.log('   RAW BODY: [unserializable]'); }
    console.log('   BODY TYPE:', typeof req.body);

    // Defensive destructure: if body is missing, use empty object to avoid crash
    const {
        audit_id, asset_id, asset_found, actual_user, actual_location_id,
        is_physical_good, is_patch_latest, is_endpoint_latest, 
        is_monitor_working, is_ups_working, additional_info, checked_by
    } = data;

    // Basic validation for required fields (prevent NULL inserts)
    const missing = [];
    if (audit_id == null) missing.push('audit_id');
    if (asset_id == null) missing.push('asset_id');
    if (missing.length > 0) {
        console.warn('   âš ï¸ Missing required fields:', missing.join(', '));
        return res.status(400).json({ message: 'Missing required fields', missing });
    }

    const query = `
        INSERT INTO audit_results 
        (audit_id, asset_id, asset_found, actual_user, actual_location_id,
         is_physical_good, is_patch_latest, is_endpoint_latest, 
         is_monitor_working, is_ups_working, additional_info, checked_by, checked_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
    `;

    const values = [
        audit_id, asset_id, asset_found, actual_user || null, actual_location_id || null, 
        is_physical_good, is_patch_latest, is_endpoint_latest, 
        is_monitor_working, is_ups_working, additional_info, checked_by
    ];
    
    // Coerce any undefined bind parameters to SQL NULL (mysql2 requires null, not undefined)
    const sanitizedValues = values.map(v => (typeof v === 'undefined' ? null : v));

    // LOG: Query and bind values (sanitized)
    console.log("   SANITIZED VALUES:", sanitizedValues);
    try { console.log('   QUERY (compact):', query.replace(/\s+/g, ' ').trim()); } catch (e) { console.log('   QUERY: [could not format]'); }

    try {
        const [result] = await pool.execute(query, sanitizedValues);
        
        // LOG: Success response and new row ID
        console.log(`   â¬…ï¸ STATUS: 201 Created. New Audit Result ID: ${result.insertId}`);
        res.status(201).json({ 
            message: "Audit results submitted successfully.", 
            id: result.insertId 
        });

    } catch (error) {
        // LOG: Error details and code, include query and bind values for debugging
        console.error("   âŒ ERROR:", error.code, error.message);
        try { console.error('   QUERY (compact):', query.replace(/\s+/g, ' ').trim()); } catch (e) {}
        try { console.error('   BIND VALUES:', sanitizedValues); } catch (e) {}
        
        if (error.code === 'ER_NO_REFERENCED_ROW_2') {
             return res.status(400).json({ message: "Invalid audit or asset ID provided.", error: error.message });
        }
        res.status(500).json({ message: "Failed to submit audit results.", error: error.message });
    }
});

// --- Start Server ---
// (moved to end of file so all routes/middleware are registered first)

// 1b. POST: Create a new asset
app.post('/api/assets', async (req, res) => {
    const data = req.body || {};

    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] POST /api/assets from ${clientIp}`);
    try { console.log('   HEADERS:', JSON.stringify(req.headers)); } catch (e) {}
    try { console.log('   RAW BODY:', JSON.stringify(req.body)); } catch (e) {}

    const {
        glpi_id, asset_tag, serial_number, model, category,
        assigned_user, location_id, glpi_import_date
    } = data;

    // basic validation
    const missing = [];
    if (!asset_tag) missing.push('asset_tag');
    if (!category) missing.push('category');
    if (missing.length > 0) {
        console.warn('   âš ï¸ Missing required fields:', missing.join(', '));
        return res.status(400).json({ message: 'Missing required fields', missing });
    }

    // validate category enum
    const allowed = ['Desktop','Laptop','Monitor','Printer','UPS'];
    if (!allowed.includes(category)) {
        return res.status(400).json({ message: 'Invalid category', allowed });
    }

    const query = `
        INSERT INTO assets
        (glpi_id, asset_tag, serial_number, model, category, assigned_user, location_id, glpi_import_date)
        VALUES (?,?, ?, ?, ?, ?, ?, COALESCE(?, NOW()))
    `;

    const values = [
        glpi_id || null, asset_tag, serial_number || null, model || null, category,
        assigned_user || null, location_id || null, glpi_import_date || null
    ];

    const sanitizedValues = values.map(v => (typeof v === 'undefined' ? null : v));
    console.log('   SANITIZED VALUES:', sanitizedValues);
    try {
        const [result] = await pool.execute(query, sanitizedValues);
        console.log(`   â¬…ï¸ STATUS: 201 Created. New Asset ID: ${result.insertId}`);
        return res.status(201).json({ message: 'Asset created', id: result.insertId });
    } catch (error) {
        console.error('   âŒ ERROR:', error.code, error.message);
        try { console.error('   QUERY (compact):', query.replace(/\s+/g, ' ').trim()); } catch (e) {}
        try { console.error('   BIND VALUES:', sanitizedValues); } catch (e) {}

        if (error.code === 'ER_DUP_ENTRY') {
            return res.status(409).json({ message: 'Duplicate asset (asset_tag or unique constraint)', error: error.message });
        }
        res.status(500).json({ message: 'Failed to create asset', error: error.message });
    }
});

// 2b. POST: Create a new audit (audit metadata)
app.post('/api/audits', async (req, res) => {
    const data = req.body || {};

    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] POST ${req.originalUrl || req.url} from ${clientIp}`);
    try { console.log('   HEADERS:', JSON.stringify(req.headers)); } catch (e) {}
    try { console.log('   RAW BODY:', JSON.stringify(req.body)); } catch (e) {}

    const { audit_name, location_id, status, start_date, end_date } = data;

    // basic validation
    const missing = [];
    if (!audit_name) missing.push('audit_name');
    if (typeof location_id === 'undefined' || location_id === null) missing.push('location_id');
    if (missing.length > 0) {
        console.warn('   âš ï¸ Missing required fields:', missing.join(', '));
        return res.status(400).json({ message: 'Missing required fields', missing });
    }

    const query = `
        INSERT INTO audits
        (audit_name, location_id, status, start_date, end_date)
        VALUES (?, ?, ?, ?, ?)
    `;

    const values = [
        audit_name, location_id, (typeof status === 'undefined' ? 0 : status),
        start_date || null, end_date || null
    ];

    const sanitizedValues = values.map(v => (typeof v === 'undefined' ? null : v));
    console.log('   SANITIZED VALUES:', sanitizedValues);

    try {
        const [result] = await pool.execute(query, sanitizedValues);
        console.log(`   â¬…ï¸ STATUS: 201 Created. New Audit ID: ${result.insertId}`);
        return res.status(201).json({ message: 'Audit created', id: result.insertId });
    } catch (error) {
        console.error('   âŒ ERROR:', error.code, error.message);
        try { console.error('   QUERY (compact):', query.replace(/\s+/g, ' ').trim()); } catch (e) {}
        try { console.error('   BIND VALUES:', sanitizedValues); } catch (e) {}

        res.status(500).json({ message: 'Failed to create audit', error: error.message });
    }
});

// Start server after all routes are registered


// GET: List locations
app.get('/api/locations', async (req, res) => {
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] GET /api/locations from ${clientIp}`);

    const query = 'SELECT id, location_name, company_name FROM locations ORDER BY id';
    try {
        const [rows] = await pool.execute(query);
        console.log(`   â¬…ï¸ STATUS: 200 OK. Returned ${rows.length} locations`);
        return res.status(200).json(rows);
    } catch (error) {
        console.error('   âŒ ERROR fetching locations:', error.code || '', error.message || error);
        return res.status(500).json({ message: 'Failed to retrieve locations', error: error.message });
    }
});

// GET : List Group by Location //

app.get('/api/locations/:branch', async (req, res) => {
    // 1. Safely extract the parameter from the URL path
    const branch = req.params.branch; 
    
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] GET /api/locations/${branch} from ${clientIp}`);

    // 2. Use a placeholder '?' in the query string instead of variable interpolation.
    // NOTE: Changed 'where' to 'WHERE' and added a table name (assumed 'locations').
    const query = 'SELECT id, location_name, company_name FROM locations WHERE location_name = ?';

    try {
        // 3. Pass the query and an array of parameters to pool.execute().
        // The library securely handles sanitization and insertion.
        const [rows] = await pool.execute(query, [branch]); 

        console.log(` Â  â¬…ï¸ STATUS: 200 OK. Returned ${rows.length} locations`);
        return res.status(200).json(rows);
    } catch (error) {
        console.error(' Â  âŒ ERROR fetching locations:', error.code || '', error.message || error);
        return res.status(500).json({ message: 'Failed to retrieve locations', error: error.message });
    }
});

// GET: Retrieve audit data (retrieve all assets from audit results with filtering and pagination)
app.get('/api/audit/data', async (req, res) => {
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] GET /api/audit/data from ${clientIp}`);

    // Query parameters for filtering and pagination
    const auditId = req.query.audit_id;
    const assetId = req.query.asset_id;
    const limit = Math.min(parseInt(req.query.limit) || 50, 1000); // Max 1000 rows
    const offset = parseInt(req.query.offset) || 0;

    try {
        // Build dynamic WHERE clause
        let whereConditions = [];
        let params = [];

        if (auditId) {
            whereConditions.push('audit_id = ?');
            params.push(auditId);
        }
        if (assetId) {
            whereConditions.push('asset_id = ?');
            params.push(assetId);
        }

        const whereClause = whereConditions.length > 0 ? 'WHERE ' + whereConditions.join(' AND ') : '';

        // Get total count
        const countQuery = `SELECT COUNT(*) as total FROM audit_results ${whereClause}`;
        const countParams = [...params];
        const [countRows] = await pool.execute(countQuery, countParams);
        const total = countRows[0].total;

        // Get paginated results
        const dataQuery = `
            SELECT 
                id, audit_id, asset_id, asset_found, actual_user, actual_location_id,
                is_physical_good, is_patch_latest, is_endpoint_latest, 
                is_monitor_working, is_ups_working, additional_info, checked_by, checked_at
            FROM audit_results 
            ${whereClause}
            ORDER BY checked_at DESC, id DESC
            LIMIT ? OFFSET ?
        `;

        const dataParams = [...params, limit, offset];
        const [rows] = await pool.execute(dataQuery, dataParams);

        console.log(`   â¬…ï¸ STATUS: 200 OK. Returned ${rows.length} audit records (Total: ${total})`);
        return res.status(200).json({
            data: rows,
            pagination: {
                total,
                limit,
                offset,
                returned: rows.length
            }
        });
    } catch (error) {
        console.error('   âŒ ERROR fetching audit data:', error.code || '', error.message || error);
        return res.status(500).json({ message: 'Failed to retrieve audit data', error: error.message });
    }
});

// GET: Retrieve audits data from audits table
app.get('/api/audits', async (req, res) => {
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] GET /api/audits from ${clientIp}`);

    // Query parameters for filtering and pagination
    const locationId = req.query.location_id;
    const status = req.query.status;
    const limit = Math.min(parseInt(req.query.limit) || 50, 1000); // Max 1000 rows
    const offset = parseInt(req.query.offset) || 0;

    try {
        // Build dynamic WHERE clause
        let whereConditions = [];
        let params = [];

        if (locationId) {
            whereConditions.push('location_id = ?');
            params.push(locationId);
        }
        if (status) {
            whereConditions.push('status = ?');
            params.push(status);
        }

        const whereClause = whereConditions.length > 0 ? 'WHERE ' + whereConditions.join(' AND ') : '';

        // Get total count
        const countQuery = `SELECT COUNT(*) as total FROM audits ${whereClause}`;
        const countParams = [...params];
        const [countRows] = await pool.execute(countQuery, countParams);
        const total = countRows[0].total;

        // Get paginated results
        const dataQuery = `
            SELECT 
                id, audit_name, location_id, status, start_date, end_date
            FROM audits 
            ${whereClause}
            ORDER BY id DESC
            LIMIT ? OFFSET ?
        `;

        const dataParams = [...params, limit, offset];
        const [rows] = await pool.execute(dataQuery, dataParams);

        console.log(`   â¬…ï¸ STATUS: 200 OK. Returned ${rows.length} audits (Total: ${total})`);
        return res.status(200).json({
            data: rows,
            pagination: {
                total,
                limit,
                offset,
                returned: rows.length
            }
        });

    } catch (error) {
        console.error('   âŒ ERROR fetching audits:', error.code || '', error.message || error);
        return res.status(500).json({ message: 'Failed to retrieve audits', error: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`\n======================================================`);
    console.log(`ðŸš€ Server is running on http://localhost:${PORT}`);
    console.log(`======================================================`);
});