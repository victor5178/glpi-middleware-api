// server.js

const express = require("express");
const mysql = require("mysql2/promise");
const cors = require("cors");
const multer = require("multer");
const path = require("path");
const fs = require("fs");
const dbConfig = require("./db.config.js");

const app = express();
const PORT = 3003;

// Middleware
app.use(cors());
app.use(express.json());

// Global logger for all POST requests to make debugging easier
app.use((req, res, next) => {
    if (req.method && req.method.toUpperCase() === 'POST') {
        const ts = new Date().toISOString();
        const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
        try {
            console.log(`[${ts}] POST ${req.originalUrl || req.url} from ${clientIp}`);
            console.log('   Headers:', JSON.stringify(req.headers));
        } catch (e) {
            console.log('   Headers: [unserializable]');
        }
        try {
            console.log('   Body:', JSON.stringify(req.body));
        } catch (e) {
            console.log('   Body: [unserializable]');
        }
    }
    next();
});

// --- Database Connection Pool ---
let pool;
try {
    pool = mysql.createPool(dbConfig);
    console.log("âœ… MySQL connection pool created successfully.");
} catch (error) {
    console.error("âŒ Failed to create MySQL connection pool:", error);
    process.exit(1);
}

// Helper wrapper to log queries and parameters for debugging
const SQL_LOGGING = (process.env.SQL_LOGGING === '1' || process.env.SQL_LOGGING === 'true');

// Helper wrapper to log queries and parameters for debugging (gated by `SQL_LOGGING`)
const execQuery = async (query, params = []) => {
    if (SQL_LOGGING) {
        try {
            const compact = String(query).replace(/\s+/g, ' ').trim();
            console.log('   QUERY:', compact);
            try { console.log('   PARAMS:', JSON.stringify(params)); } catch (e) { console.log('   PARAMS: [unserializable]'); }
        } catch (e) {
            console.log('   QUERY: [unserializable]');
        }
    }
    return pool.execute(query, params);
};

// Print SQL logging state at startup
console.log(`   SQL logging: ${SQL_LOGGING ? 'enabled' : 'disabled'}`);

// --- API Endpoints ---

// 1. GET: Retrieve a single asset by asset_tag
app.get("/api/assets/:assetTag", async (req, res) => {
    const { assetTag } = req.params;
    
    // LOG: Incoming request
    console.log(`\nâž¡ï¸ GET /api/assets/${assetTag}`);
    
    const query = "SELECT id, asset_tag, category, assigned_user, location_id FROM assets WHERE asset_tag = ?";
    
    // LOG: Query being executed
    console.log(`   QUERY: ${query.replace('?', `'${assetTag}'`)}`);
    
    try {
        const [rows] = await execQuery(query, [assetTag]);
        
        if (rows.length === 0) {
            // LOG: 404 response
            console.log(`   â¬…ï¸ STATUS: 404 Not Found (Asset: ${assetTag})`);
            return res.status(404).json({ message: "Asset not found" });
        }
        
        // LOG: Success response and returned data
        console.log(`   â¬…ï¸ STATUS: 200 OK. Asset ID: ${rows[0].id}`);
        res.status(200).json(rows[0]);
    } catch (error) {
        // LOG: Error details
        console.error("   âŒ ERROR:", error.message);
        res.status(500).json({ message: "Error retrieving asset data", error: error.message });
    }
});

// 2. POST: Submit Audit Results
app.post('/api/audit/submit', async (req, res) => {
    const data = req.body || {};

    // LOG: Incoming request and payload data (enhanced for debugging)
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] POST /api/audit/submit from ${clientIp}`);
    try { console.log('   HEADERS:', JSON.stringify(req.headers)); } catch (e) { console.log('   HEADERS: [unserializable]'); }
    try { console.log('   RAW BODY:', JSON.stringify(req.body)); } catch (e) { console.log('   RAW BODY: [unserializable]'); }
    console.log('   BODY TYPE:', typeof req.body);

    // Grab fields from the incoming body
    let {
        audit_id, asset_id, asset_found, actual_user, actual_location_id,
        is_physical_good, is_patch_latest, is_endpoint_latest,
        is_monitor_working, is_ups_working, additional_info, checked_by
    } = data;

    // --- FIX: TRANSLATE GLPI_ID TO INTERNAL ID ---
    try {
        if (asset_id != null) {
            // First treat incoming asset_id as a GLPI id and try to map
            const [rows] = await execQuery('SELECT id FROM assets WHERE glpi_id = ?', [asset_id]);
            if (rows.length > 0) {
                console.log(`   ðŸ”„ Mapped GLPI ID ${asset_id} to Internal ID ${rows[0].id}`);
                asset_id = rows[0].id; // replace with internal id
            } else {
                // If not found by glpi_id, check whether the provided value is already an internal id
                const [checkId] = await execQuery('SELECT id FROM assets WHERE id = ?', [asset_id]);
                if (checkId.length === 0) {
                    console.error(`   âŒ Asset ID ${asset_id} not found in DB (checked as glpi_id and internal id)`);
                    return res.status(404).json({ message: 'Asset not found' });
                }
                // If found here, asset_id remains the internal id
            }
        }
    } catch (err) {
        console.error('   âŒ ERROR mapping asset id:', err.message);
        return res.status(500).json({ message: 'Failed to resolve asset id', error: err.message });
    }
    // --- END FIX ---

    // Basic validation for required fields (prevent NULL inserts)
    const missing = [];
    if (audit_id == null) missing.push('audit_id');
    if (asset_id == null) missing.push('asset_id');
    if (missing.length > 0) {
        console.warn('   âš ï¸ Missing required fields:', missing.join(', '));
        return res.status(400).json({ message: 'Missing required fields', missing });
    }

    try {
        // --- VALIDATION: Check if audit_id and asset_id exist ---
        const [auditCheck] = await execQuery('SELECT id FROM audits WHERE id = ?', [audit_id]);
        if (auditCheck.length === 0) {
            console.warn(`   âš ï¸ Audit ID ${audit_id} does not exist`);
            return res.status(404).json({ message: 'Audit not found', audit_id });
        }
        console.log(`   âœ… Audit ID ${audit_id} exists`);

        const [assetCheck] = await execQuery('SELECT id FROM assets WHERE id = ?', [asset_id]);
        if (assetCheck.length === 0) {
            console.warn(`   âš ï¸ Asset ID ${asset_id} does not exist`);
            return res.status(404).json({ message: 'Asset not found', asset_id });
        }
        console.log(`   âœ… Asset ID ${asset_id} exists`);

        // --- CHECK IF AUDIT RESULT ALREADY EXISTS ---
        const [existingResult] = await execQuery(
            'SELECT id FROM audit_results WHERE audit_id = ? AND asset_id = ?',
            [audit_id, asset_id]
        );

        const values = [
            asset_found, actual_user || null, actual_location_id || null, 
            is_physical_good, is_patch_latest, is_endpoint_latest, 
            is_monitor_working, is_ups_working, additional_info, checked_by
        ];

        const sanitizedValues = values.map(v => (typeof v === 'undefined' ? null : v));

        if (existingResult.length > 0) {
            // --- UPDATE EXISTING AUDIT RESULT ---
            const existingId = existingResult[0].id;
            const updateQuery = `
                UPDATE audit_results
                SET asset_found = ?, actual_user = ?, actual_location_id = ?,
                    is_physical_good = ?, is_patch_latest = ?, is_endpoint_latest = ?,
                    is_monitor_working = ?, is_ups_working = ?, additional_info = ?,
                    checked_by = ?, checked_at = NOW()
                WHERE id = ?
            `;

            const updateValues = [...sanitizedValues, existingId];
            console.log('   ðŸ”„ UPDATE Query - SANITIZED VALUES:', updateValues);

            const [updateResult] = await execQuery(updateQuery, updateValues);
            console.log(`   â¬…ï¸ STATUS: 200 OK. Audit Result updated. ID: ${existingId}`);
            return res.status(200).json({
                message: 'Audit results updated successfully.',
                id: existingId,
                action: 'updated'
            });

        } else {
            // --- CREATE NEW AUDIT RESULT ---
            const insertQuery = `
                INSERT INTO audit_results 
                (audit_id, asset_id, asset_found, actual_user, actual_location_id,
                 is_physical_good, is_patch_latest, is_endpoint_latest, 
                 is_monitor_working, is_ups_working, additional_info, checked_by, checked_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
            `;

            const insertValues = [audit_id, asset_id, ...sanitizedValues];
            console.log('   ðŸ“ INSERT Query - SANITIZED VALUES:', insertValues);

            const [insertResult] = await execQuery(insertQuery, insertValues);
            console.log(`   â¬…ï¸ STATUS: 201 Created. New Audit Result ID: ${insertResult.insertId}`);
            return res.status(201).json({
                message: 'Audit results submitted successfully.',
                id: insertResult.insertId,
                action: 'created'
            });
        }

    } catch (error) {
        // LOG: Error details and code, include query and bind values for debugging
        console.error('   âŒ ERROR:', error.code, error.message);
        
        if (error.code === 'ER_NO_REFERENCED_ROW_2') {
             return res.status(400).json({ message: 'Invalid audit or asset ID provided.', error: error.message });
        }
        return res.status(500).json({ message: 'Failed to submit audit results.', error: error.message });
    }
});

// --- Start Server ---
// (moved to end of file so all routes/middleware are registered first)

// 1b. POST: Create a new asset
app.post('/api/assets', async (req, res) => {
    const data = req.body || {};

    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] POST /api/assets from ${clientIp}`);
    try { console.log('   HEADERS:', JSON.stringify(req.headers)); } catch (e) {}
    try { console.log('   RAW BODY:', JSON.stringify(req.body)); } catch (e) {}

    const {
        glpi_id, asset_tag, serial_number, model, category,
        assigned_user, location_id, glpi_import_date
    } = data;

    // basic validation
    const missing = [];
    if (!asset_tag) missing.push('asset_tag');
    if (!category) missing.push('category');
    if (missing.length > 0) {
        console.warn('   âš ï¸ Missing required fields:', missing.join(', '));
        return res.status(400).json({ message: 'Missing required fields', missing });
    }

    // validate category enum
    const allowed = ['Desktop','Laptop','Monitor','Printer','UPS','Computer','Peripheral'];
    if (!allowed.includes(category)) {
        return res.status(400).json({ message: 'Invalid category', allowed });
    }

    try {
        // Check if asset exists by asset_tag or glpi_id
        let existingAsset = null;
        let checkQuery = 'SELECT id FROM assets WHERE asset_tag = ?';
        let checkParams = [asset_tag];

        console.log(`   Checking if asset exists with asset_tag: ${asset_tag}`);
        const [existingRows] = await execQuery(checkQuery, checkParams);
        
        if (existingRows.length > 0) {
            existingAsset = existingRows[0];
            console.log(`   âœ… Asset found with ID: ${existingAsset.id}. Will UPDATE the existing record.`);
        } else if (glpi_id) {
            // Also check by glpi_id if provided
            checkQuery = 'SELECT id FROM assets WHERE glpi_id = ?';
            checkParams = [glpi_id];
            console.log(`   Checking if asset exists with glpi_id: ${glpi_id}`);
            const [glpiRows] = await execQuery(checkQuery, checkParams);
            if (glpiRows.length > 0) {
                existingAsset = glpiRows[0];
                console.log(`   âœ… Asset found with ID: ${existingAsset.id}. Will UPDATE the existing record.`);
            }
        }

        // Prepare values
        const values = [
            glpi_id || null, asset_tag, serial_number || null, model || null, category,
            assigned_user || null, location_id || null, glpi_import_date || null
        ];

        const sanitizedValues = values.map(v => (typeof v === 'undefined' ? null : v));

        if (existingAsset) {
            // UPDATE existing asset
            const updateQuery = `
                UPDATE assets
                SET glpi_id = ?, asset_tag = ?, serial_number = ?, model = ?, category = ?, 
                    assigned_user = ?, location_id = ?, glpi_import_date = COALESCE(?, glpi_import_date)
                WHERE id = ?
            `;
            const updateParams = [...sanitizedValues, existingAsset.id];
            
            console.log('   SANITIZED VALUES (UPDATE):', updateParams);
            await execQuery(updateQuery, updateParams);
            console.log(`   â¬…ï¸ STATUS: 200 OK. Asset updated with ID: ${existingAsset.id}`);
            return res.status(200).json({ 
                message: 'Asset updated successfully', 
                id: existingAsset.id,
                action: 'updated'
            });
        } else {
            // CREATE new asset
            const insertQuery = `
                INSERT INTO assets
                (glpi_id, asset_tag, serial_number, model, category, assigned_user, location_id, glpi_import_date)
                VALUES (?, ?, ?, ?, ?, ?, ?, COALESCE(?, NOW()))
            `;
            
            console.log('   SANITIZED VALUES (INSERT):', sanitizedValues);
            const [result] = await execQuery(insertQuery, sanitizedValues);
            console.log(`   â¬…ï¸ STATUS: 201 Created. New Asset ID: ${result.insertId}`);
            return res.status(201).json({ 
                message: 'Asset created successfully', 
                id: result.insertId,
                action: 'created'
            });
        }
    } catch (error) {
        console.error('   âŒ ERROR:', error.code, error.message);
        try { console.error('   BIND VALUES:', sanitizedValues); } catch (e) {}

        if (error.code === 'ER_DUP_ENTRY') {
            return res.status(409).json({ message: 'Duplicate asset (asset_tag or unique constraint)', error: error.message });
        }
        res.status(500).json({ message: 'Failed to create or update asset', error: error.message });
    }
});

// 1c. DELETE: Remove an asset by asset_tag
app.delete('/api/assets/delete/:assetTag', async (req, res) => {
    const { assetTag } = req.params;

    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] DELETE /api/assets/delete/${assetTag} from ${clientIp}`);

    // Validate asset tag
    if (!assetTag) {
        console.warn('   âš ï¸ Invalid asset tag');
        return res.status(400).json({ message: 'Invalid asset tag provided' });
    }

    try {
        // First check if asset exists by asset_tag
        const [existingAsset] = await execQuery('SELECT id, asset_tag FROM assets WHERE asset_tag = ?', [assetTag]);
        
        if (existingAsset.length === 0) {
            console.warn(`   âš ï¸ Asset tag ${assetTag} not found`);
            return res.status(404).json({ message: 'Asset not found', asset_tag: assetTag });
        }

        const assetId = existingAsset[0].id;
        console.log(`   âœ… Asset found: Tag: ${assetTag}, ID: ${assetId}`);

        // Check if asset has related audit_results
        const [relatedResults] = await execQuery('SELECT COUNT(*) as count FROM audit_results WHERE asset_id = ?', [assetId]);
        const resultCount = relatedResults[0].count;
        
        if (resultCount > 0) {
            console.warn(`   âš ï¸ Asset ${assetTag} has ${resultCount} related audit result(s). Cannot delete due to foreign key constraint.`);
            return res.status(409).json({ 
                message: 'Cannot delete asset: it has related audit results', 
                asset_tag: assetTag,
                asset_id: assetId,
                related_audit_results: resultCount
            });
        }

        // Delete the asset by ID
        const [result] = await execQuery('DELETE FROM assets WHERE id = ?', [assetId]);

        if (result.affectedRows === 0) {
            console.warn(`   âš ï¸ Failed to delete asset ${assetTag}`);
            return res.status(500).json({ message: 'Failed to delete asset' });
        }

        console.log(`   â¬…ï¸ STATUS: 200 OK. Asset deleted. Tag: ${assetTag}, ID: ${assetId}`);
        return res.status(200).json({
            message: 'Asset deleted successfully',
            asset_tag: assetTag,
            asset_id: assetId,
            action: 'deleted'
        });

    } catch (error) {
        console.error('   âŒ ERROR:', error.code, error.message);
        
        if (error.code === 'ER_NO_REFERENCED_ROW_2' || error.code === 'ER_ROW_IS_REFERENCED') {
            return res.status(409).json({ 
                message: 'Cannot delete asset: foreign key constraint violation',
                error: error.message 
            });
        }
        
        res.status(500).json({ message: 'Failed to delete asset', error: error.message });
    }
});

// 2b. POST: Create a new audit (audit metadata)
app.post('/api/audits', async (req, res) => {
    const data = req.body || {};

    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] POST ${req.originalUrl || req.url} from ${clientIp}`);
    try { console.log('   HEADERS:', JSON.stringify(req.headers)); } catch (e) {}
    try { console.log('   RAW BODY:', JSON.stringify(req.body)); } catch (e) {}

    const { audit_name, location_id, status, start_date, end_date } = data;

    // basic validation
    const missing = [];
    if (!audit_name) missing.push('audit_name');
    if (typeof location_id === 'undefined' || location_id === null) missing.push('location_id');
    if (missing.length > 0) {
        console.warn('   âš ï¸ Missing required fields:', missing.join(', '));
        return res.status(400).json({ message: 'Missing required fields', missing });
    }

    const query = `
        INSERT INTO audits
        (audit_name, location_id, status, start_date, end_date)
        VALUES (?, ?, ?, ?, ?)
    `;

    const values = [
        audit_name, location_id, (typeof status === 'undefined' ? 0 : status),
        start_date || null, end_date || null
    ];

    const sanitizedValues = values.map(v => (typeof v === 'undefined' ? null : v));
    console.log('   SANITIZED VALUES:', sanitizedValues);

    try {
        const [result] = await execQuery(query, sanitizedValues);
        console.log(`   â¬…ï¸ STATUS: 201 Created. New Audit ID: ${result.insertId}`);
        return res.status(201).json({ message: 'Audit created', id: result.insertId });
    } catch (error) {
        console.error('   âŒ ERROR:', error.code, error.message);
        try { console.error('   QUERY (compact):', query.replace(/\s+/g, ' ').trim()); } catch (e) {}
        try { console.error('   BIND VALUES:', sanitizedValues); } catch (e) {}

        res.status(500).json({ message: 'Failed to create audit', error: error.message });
    }
});

// Start server after all routes are registered


// GET: List locations
app.get('/api/locations', async (req, res) => {
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] GET /api/locations from ${clientIp}`);

    const query = 'SELECT id, location_name, company_name FROM locations ORDER BY id';
    try {
        const [rows] = await execQuery(query);
        console.log(`   â¬…ï¸ STATUS: 200 OK. Returned ${rows.length} locations`);
        return res.status(200).json(rows);
    } catch (error) {
        console.error('   âŒ ERROR fetching locations:', error.code || '', error.message || error);
        return res.status(500).json({ message: 'Failed to retrieve locations', error: error.message });
    }
});

// GET : List Group by Location //

app.get('/api/locations/:branch', async (req, res) => {
    // 1. Safely extract the parameter from the URL path
    const branch = req.params.branch; 
    
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] GET /api/locations/${branch} from ${clientIp}`);

    // 2. Use a placeholder '?' in the query string instead of variable interpolation.
    // NOTE: Changed 'where' to 'WHERE' and added a table name (assumed 'locations').
    const query = 'SELECT id, location_name, company_name FROM locations WHERE location_name = ?';

    try {
        // 3. Pass the query and an array of parameters to pool.execute().
        // The library securely handles sanitization and insertion.
        const [rows] = await execQuery(query, [branch]); 

        console.log(` Â  â¬…ï¸ STATUS: 200 OK. Returned ${rows.length} locations`);
        return res.status(200).json(rows);
    } catch (error) {
        console.error(' Â  âŒ ERROR fetching locations:', error.code || '', error.message || error);
        return res.status(500).json({ message: 'Failed to retrieve locations', error: error.message });
    }
});

// GET: Retrieve audit data (retrieve all assets from audit results with filtering and pagination)
app.get('/api/audit/data', async (req, res) => {
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] GET /api/audit/data from ${clientIp}`);

    // Query parameters for filtering and pagination
    const auditId = req.query.audit_id;
    const assetId = req.query.asset_id;
    const limit = Math.min(parseInt(req.query.limit) || 50, 1000); // Max 1000 rows
    const offset = parseInt(req.query.offset) || 0;

    try {
        // Build dynamic WHERE clause
        let whereConditions = [];
        let params = [];

        if (auditId) {
            whereConditions.push('audit_id = ?');
            params.push(auditId);
        }
        if (assetId) {
            whereConditions.push('asset_id = ?');
            params.push(assetId);
        }

        const whereClause = whereConditions.length > 0 ? 'WHERE ' + whereConditions.join(' AND ') : '';

        // Use LEFT JOIN with assets so we can surface asset fields (serial, model, assigned_user)
        const fromClause = 'FROM audit_results ar LEFT JOIN assets a ON a.id = ar.asset_id';

        // Get total count
        const countQuery = `SELECT COUNT(*) as total ${fromClause} ${whereClause}`;
        const countParams = [...params];
        const [countRows] = await execQuery(countQuery, countParams);
        const total = countRows[0].total;

        // Get paginated results
        const dataQuery = `
            SELECT 
                ar.id AS id,
                ar.audit_id,
                ar.asset_id,
                a.asset_tag,
                a.serial_number,
                a.model,
                a.assigned_user AS assigned_user,
                ar.asset_found,
                ar.actual_user,
                ar.actual_location_id,
                ar.is_physical_good,
                ar.is_patch_latest,
                ar.is_endpoint_latest,
                ar.is_monitor_working,
                ar.is_ups_working,
                ar.additional_info,
                ar.checked_by,
                ar.checked_at
            ${fromClause}
            ${whereClause}
            ORDER BY ar.checked_at DESC, ar.id DESC
            LIMIT ? OFFSET ?
        `;

        const dataParams = [...params, limit, offset];
        const [rows] = await execQuery(dataQuery, dataParams);

        console.log(`   â¬…ï¸ STATUS: 200 OK. Returned ${rows.length} audit records (Total: ${total})`);
        return res.status(200).json({
            data: rows,
            pagination: {
                total,
                limit,
                offset,
                returned: rows.length
            }
        });
    } catch (error) {
        console.error('   âŒ ERROR fetching audit data:', error.code || '', error.message || error);
        return res.status(500).json({ message: 'Failed to retrieve audit data', error: error.message });
    }
});

// GET: Retrieve audits data from audits table
app.get('/api/audits', async (req, res) => {
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] GET /api/audits from ${clientIp}`);

    // Query parameters for filtering and pagination
    const locationId = req.query.location_id;
    const status = req.query.status;
    const limit = Math.min(parseInt(req.query.limit) || 50, 1000); // Max 1000 rows
    const offset = parseInt(req.query.offset) || 0;

    try {
        // Build dynamic WHERE clause
        let whereConditions = [];
        let params = [];

        if (locationId) {
            whereConditions.push('location_id = ?');
            params.push(locationId);
        }
        if (status) {
            whereConditions.push('status = ?');
            params.push(status);
        }

        const whereClause = whereConditions.length > 0 ? 'WHERE ' + whereConditions.join(' AND ') : '';

        // Get total count
        const countQuery = `SELECT COUNT(*) as total FROM audits ${whereClause}`;
        const countParams = [...params];
        const [countRows] = await execQuery(countQuery, countParams);
        const total = countRows[0].total;

        // Get paginated results
        const dataQuery = `
            SELECT 
                id, audit_name, location_id, status, start_date, end_date
            FROM audits 
            ${whereClause}
            ORDER BY id DESC
            LIMIT ? OFFSET ?
        `;

        const dataParams = [...params, limit, offset];
        const [rows] = await execQuery(dataQuery, dataParams);

        console.log(`   â¬…ï¸ STATUS: 200 OK. Returned ${rows.length} audits (Total: ${total})`);
        return res.status(200).json({
            data: rows,
            pagination: {
                total,
                limit,
                offset,
                returned: rows.length
            }
        });

    } catch (error) {
        console.error('   âŒ ERROR fetching audits:', error.code || '', error.message || error);
        return res.status(500).json({ message: 'Failed to retrieve audits', error: error.message });
    }
});

// --- Image Upload Configuration ---
const uploadDir = path.join(__dirname, 'uploads');

// Ensure uploads directory exists
if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
}

// Configure multer for file uploads
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        // Create folder structure: uploads/YYYYMMDD
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const ymd = `${year}${month}${day}`;
        const folderPath = path.join(uploadDir, ymd);

        // Create folder if it doesn't exist
        fs.mkdirSync(folderPath, { recursive: true });
        cb(null, folderPath);
    },
    filename: (req, file, cb) => {
        // Filename format: SERIAL_DDMMYY_HHMMSS.ext (falls back to COMPUTERNAME or UNKNOWN)
        const now = new Date();
        const dd = String(now.getDate()).padStart(2, '0');
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const yy = String(now.getFullYear()).slice(-2);
        const hh = String(now.getHours()).padStart(2, '0');
        const min = String(now.getMinutes()).padStart(2, '0');
        const ss = String(now.getSeconds()).padStart(2, '0');
        const time = `${hh}${min}${ss}`;
        const ext = path.extname(file.originalname);

        const sanitize = (s) => {
            if (s === undefined || s === null || s === '') return 'UNKNOWN';
            return String(s)
                .trim()
                .replace(/\s+/g, '_')
                .replace(/[^a-zA-Z0-9-_]/g, '_')
                .toUpperCase()
                .slice(0, 50);
        };

        // 1) Use explicit computer_name from client if provided
        const explicitName = req.body && req.body.computer_name;
        if (explicitName) {
            const safe = sanitize(explicitName);
            return cb(null, `${safe}_${dd}${mm}${yy}_${time}${ext}`);
        }

        // 2) Try to resolve from provided asset_id (assets.id)
        const assetId = req.body && (req.body.asset_id || req.body.assetId);
        if (assetId) {
            execQuery(
                `SELECT a.serial_number FROM assets a LEFT JOIN audit_results ar ON a.id = ar.asset_id WHERE a.id = ? LIMIT 1`,
                [assetId]
            ).then(([rows]) => {
                const serial = (rows && rows[0] && rows[0].serial_number) ? rows[0].serial_number : null;
                const base = serial || assetId;
                const safe = sanitize(base);
                cb(null, `${safe}_${dd}${mm}${yy}_${time}${ext}`);
            }).catch(err => {
                console.error('   âŒ ERROR resolving serial_number by asset_id for filename:', err && err.message);
                cb(null, `UNKNOWN_${dd}${mm}${yy}_${time}${ext}`);
            });
            return;
        }

        // 3) Otherwise try to resolve from audit_result_id -> asset -> serial_number
        const auditResultId = req.body && (req.body.audit_result_id || req.body.auditResultId || req.body.audit_id);
        if (auditResultId) {
            execQuery(
                `SELECT a.serial_number FROM assets a LEFT JOIN audit_results ar ON a.id = ar.asset_id WHERE ar.id = ? LIMIT 1`,
                [auditResultId]
            ).then(([rows]) => {
                const serial = (rows && rows[0] && rows[0].serial_number) ? rows[0].serial_number : null;
                const base = serial || auditResultId;
                const safe = sanitize(base);
                cb(null, `${safe}_${dd}${mm}${yy}_${time}${ext}`);
            }).catch(err => {
                console.error('   âŒ ERROR resolving serial_number for filename:', err && err.message);
                cb(null, `UNKNOWN_${dd}${mm}${yy}_${time}${ext}`);
            });
            return;
        }

        // 4) Final fallback
        cb(null, `UNKNOWN_${dd}${mm}${yy}_${time}${ext}`);
    }
});

const upload = multer({
    storage: storage,
    limits: { fileSize: 50 * 1024 * 1024 }, // 50MB max file size
    fileFilter: (req, file, cb) => {
        // Allow only image files
        const allowedMimes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/bmp'];
        if (allowedMimes.includes(file.mimetype)) {
            cb(null, true);
        } else {
            cb(new Error('Only image files are allowed (jpeg, png, gif, webp, bmp)'));
        }
    }
});

// POST: Upload audit image
app.post('/api/audit/upload-image', upload.single('image'), async (req, res) => {
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] POST /api/audit/upload-image from ${clientIp}`);

    try {
        if (!req.file) {
            console.warn('   âš ï¸ No file uploaded');
            return res.status(400).json({ message: 'No image file provided' });
        }

        const { audit_result_id, computer_name, asset_id } = req.body;

        // Require at least one: audit_result_id OR asset_id OR computer_name
        if (!audit_result_id && !asset_id && !computer_name) {
            console.warn('   âš ï¸ Missing required fields: audit_result_id OR asset_id OR computer_name');
            return res.status(400).json({ message: 'Missing required field: provide audit_result_id or asset_id or computer_name' });
        }

        // Construct the folder and relative image path (current filename)
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const folderPath = `uploads/${year}${month}${day}`;
        const oldFilename = req.file.filename;
        const oldFullPath = req.file.path;

        console.log(`   ðŸ“ Image saved to: ${oldFullPath}`);
        console.log(`   ðŸ“¸ Original filename: ${oldFilename}`);

        // Helper sanitize (match storage.filename sanitize)
        const sanitize = (s) => {
            if (s === undefined || s === null || s === '') return 'UNKNOWN';
            return String(s)
                .trim()
                .replace(/\s+/g, '_')
                .replace(/[^a-zA-Z0-9-_]/g, '_')
                .toUpperCase()
                .slice(0, 50);
        };

        // Resolve desired base name: computer_name > asset.serial_number (by asset_id) > asset.serial_number (by audit_result_id)
        let finalBase = null;
        if (computer_name) {
            finalBase = sanitize(computer_name);
        } else if (asset_id) {
            try {
                const [rows] = await execQuery('SELECT serial_number FROM assets WHERE id = ? LIMIT 1', [asset_id]);
                const serial = (rows && rows[0] && rows[0].serial_number) ? rows[0].serial_number : null;
                finalBase = sanitize(serial || asset_id);
            } catch (err) {
                console.error('   âŒ ERROR resolving serial_number by asset_id after upload:', err && err.message);
                finalBase = sanitize(asset_id);
            }
        } else if (audit_result_id) {
            try {
                const [rows] = await execQuery(
                    'SELECT a.serial_number FROM assets a LEFT JOIN audit_results ar ON a.id = ar.asset_id WHERE ar.id = ? LIMIT 1',
                    [audit_result_id]
                );
                const serial = (rows && rows[0] && rows[0].serial_number) ? rows[0].serial_number : null;
                finalBase = sanitize(serial || audit_result_id);
            } catch (err) {
                console.error('   âŒ ERROR resolving serial_number by audit_result_id after upload:', err && err.message);
                finalBase = sanitize(audit_result_id);
            }
        } else {
            finalBase = 'UNKNOWN';
        }

        // Build new filename with date and timestamp
        const dd = String(now.getDate()).padStart(2, '0');
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const yy = String(now.getFullYear()).slice(-2);
        const hh = String(now.getHours()).padStart(2, '0');
        const min = String(now.getMinutes()).padStart(2, '0');
        const ss = String(now.getSeconds()).padStart(2, '0');
        const time = `${hh}${min}${ss}`;
        const ext = path.extname(oldFilename) || path.extname(req.file.originalname) || '';
        const newFilename = audit_result_id ? `${finalBase}_AR${audit_result_id}_${dd}${mm}${yy}_${time}${ext}` : `${finalBase}_${dd}${mm}${yy}_${time}${ext}`;
        const newFullPath = path.join(path.dirname(oldFullPath), newFilename);

        try {
            await fs.promises.rename(oldFullPath, newFullPath);
            console.log(`   ðŸ” Renamed file to: ${newFullPath}`);
        } catch (err) {
            console.error('   âŒ ERROR renaming uploaded file:', err && err.message);
            // If rename fails, continue but report original filename
        }

        const imgPath = `${folderPath}/${newFilename}`;
        console.log(`   ðŸ’¾ DB path: ${imgPath}`);

        // Update audit_results table with image path if audit_result_id provided
        if (audit_result_id) {
            const updateQuery = `
                UPDATE audit_results
                SET img_dir = ?
                WHERE id = ?
            `;
            const [result] = await execQuery(updateQuery, [imgPath, audit_result_id]);
            if (result.affectedRows === 0) {
                console.warn(`   âš ï¸ Audit result ID ${audit_result_id} not found`);
                return res.status(404).json({ message: 'Audit result not found' });
            }
            console.log(`   â¬…ï¸ STATUS: 200 OK. Image uploaded and audit_result updated`);
            return res.status(200).json({
                message: 'Image uploaded successfully',
                file: {
                    filename: newFilename,
                    originalName: req.file.originalname,
                    size: req.file.size,
                    path: imgPath,
                    fullPath: newFullPath
                },
                updated_audit_result_id: audit_result_id
            });
        }

        // If no audit_result_id provided, return file info (DB not updated)
        return res.status(200).json({
            message: 'Image uploaded successfully (DB not updated - no audit_result_id provided)',
            file: {
                filename: newFilename,
                originalName: req.file.originalname,
                size: req.file.size,
                path: imgPath,
                fullPath: newFullPath
            }
        });

    } catch (error) {
        console.error('   âŒ ERROR uploading image:', error.message);
        return res.status(500).json({
            message: 'Failed to upload image',
            error: error.message
        });
    }
});

// GET: List scanned items for a specific audit (audit_id)
app.get('/api/audit/:auditId/scanned-items', async (req, res) => {
    const auditId = req.params.auditId;
    const timestamp = new Date().toISOString();
    const clientIp = req.headers['x-forwarded-for'] || (req.socket && req.socket.remoteAddress) || req.ip || 'unknown';
    console.log(`\n[${timestamp}] GET /api/audit/${auditId}/scanned-items from ${clientIp}`);

    if (!auditId) {
        return res.status(400).json({ message: 'Missing auditId parameter' });
    }

    // optional pagination
    const limit = Math.min(parseInt(req.query.limit) || 100, 1000);
    const offset = parseInt(req.query.offset) || 0;

    const query = `
        SELECT 
            ar.id AS audit_result_id,
            ar.audit_id,
            ar.asset_id,
            a.asset_tag,
            a.serial_number,
            a.model,
            a.assigned_user AS assigned_user,
            ar.asset_found,
            ar.actual_user,
            ar.actual_location_id,
            ar.is_physical_good,
            ar.is_patch_latest,
            ar.is_endpoint_latest,
            ar.is_monitor_working,
            ar.is_ups_working,
            ar.additional_info,
            ar.checked_by,
            ar.checked_at,
            ar.img_dir
        FROM audit_results ar
        LEFT JOIN assets a ON a.id = ar.asset_id
        WHERE ar.audit_id = ?
        ORDER BY ar.checked_at DESC, ar.id DESC
        LIMIT ? OFFSET ?
    `;

    try {
        const [rows] = await execQuery(query, [auditId, limit, offset]);
        console.log(`   â¬…ï¸ STATUS: 200 OK. Returned ${rows.length} scanned items for audit ${auditId}`);
        return res.status(200).json({
            audit_id: auditId,
            returned: rows.length,
            limit,
            offset,
            data: rows
        });
    } catch (error) {
        console.error('   âŒ ERROR fetching scanned items:', error && error.message);
        return res.status(500).json({ message: 'Failed to retrieve scanned items', error: error && error.message });
    }
});
app.listen(PORT, () => {
    console.log(`\n======================================================`);
    console.log(`ðŸš€ Server is running on http://localhost:${PORT}`);
    console.log(`======================================================`);
});
